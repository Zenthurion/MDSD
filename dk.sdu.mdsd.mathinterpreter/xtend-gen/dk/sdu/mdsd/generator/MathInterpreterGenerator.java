/**
 * generated by Xtext 2.16.0
 */
package dk.sdu.mdsd.generator;

import com.google.common.base.Objects;
import com.google.common.collect.Iterators;
import dk.sdu.mdsd.mathInterpreter.Bracket;
import dk.sdu.mdsd.mathInterpreter.Expression;
import dk.sdu.mdsd.mathInterpreter.MultiplyOrDivide;
import dk.sdu.mdsd.mathInterpreter.Num;
import dk.sdu.mdsd.mathInterpreter.PlusOrMinus;
import dk.sdu.mdsd.mathInterpreter.Primary;
import dk.sdu.mdsd.mathInterpreter.Solution;
import dk.sdu.mdsd.mathInterpreter.Variable;
import dk.sdu.mdsd.mathInterpreter.VariableRef;
import java.util.Arrays;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtext.generator.AbstractGenerator;
import org.eclipse.xtext.generator.IFileSystemAccess2;
import org.eclipse.xtext.generator.IGeneratorContext;
import org.eclipse.xtext.xbase.lib.InputOutput;

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
@SuppressWarnings("all")
public class MathInterpreterGenerator extends AbstractGenerator {
  @Override
  public void doGenerate(final Resource resource, final IFileSystemAccess2 fsa, final IGeneratorContext context) {
    Solution math = Iterators.<Solution>filter(resource.getAllContents(), Solution.class).next();
    InputOutput.<String>println(this.variablesAsString(math));
    String _asString = this.asString(math);
    String _plus = (_asString + " = ");
    int _evaluate = this.evaluate(math);
    String _plus_1 = (_plus + Integer.valueOf(_evaluate));
    InputOutput.<String>println(_plus_1);
  }
  
  protected int _evaluate(final Solution it) {
    return this.evaluate(it.getExpression());
  }
  
  protected int _evaluate(final Expression it) {
    return this.evaluate(it.getExp());
  }
  
  protected int _evaluate(final PlusOrMinus it) {
    MultiplyOrDivide _right = it.getRight();
    boolean _tripleEquals = (_right == null);
    if (_tripleEquals) {
      return this.evaluate(it.getLeft());
    } else {
      String _operator = it.getOperator();
      boolean _equals = Objects.equal(_operator, "+");
      if (_equals) {
        int _evaluate = this.evaluate(it.getLeft());
        int _evaluate_1 = this.evaluate(it.getRight());
        return (_evaluate + _evaluate_1);
      } else {
        int _evaluate_2 = this.evaluate(it.getLeft());
        int _evaluate_3 = this.evaluate(it.getRight());
        return (_evaluate_2 - _evaluate_3);
      }
    }
  }
  
  protected int _evaluate(final MultiplyOrDivide it) {
    Primary _right = it.getRight();
    boolean _tripleEquals = (_right == null);
    if (_tripleEquals) {
      return this.evaluate(it.getLeft());
    } else {
      String _operator = it.getOperator();
      boolean _equals = Objects.equal(_operator, "*");
      if (_equals) {
        int _evaluate = this.evaluate(it.getLeft());
        int _evaluate_1 = this.evaluate(it.getRight());
        return (_evaluate * _evaluate_1);
      } else {
        int _evaluate_2 = this.evaluate(it.getLeft());
        int _evaluate_3 = this.evaluate(it.getRight());
        return (_evaluate_2 / _evaluate_3);
      }
    }
  }
  
  protected int _evaluate(final Num it) {
    return it.getValue();
  }
  
  protected int _evaluate(final VariableRef it) {
    return this.evaluate(it.getValue().getValue());
  }
  
  protected int _evaluate(final Bracket it) {
    return this.evaluate(it.getValue());
  }
  
  public String variablesAsString(final Solution it) {
    String res = "";
    EList<Variable> _variables = it.getVariables();
    for (final Variable v : _variables) {
      String _res = res;
      String _asString = this.asString(v);
      String _plus = (_asString + "\n");
      res = (_res + _plus);
    }
    return res;
  }
  
  protected String _asString(final Solution it) {
    return this.asString(it.getExpression());
  }
  
  protected String _asString(final Expression it) {
    return this.asString(it.getExp());
  }
  
  protected String _asString(final PlusOrMinus it) {
    MultiplyOrDivide _right = it.getRight();
    boolean _tripleEquals = (_right == null);
    if (_tripleEquals) {
      return this.asString(it.getLeft());
    } else {
      String _asString = this.asString(it.getLeft());
      String _plus = (_asString + " ");
      String _operator = it.getOperator();
      String _plus_1 = (_plus + _operator);
      String _plus_2 = (_plus_1 + " ");
      String _asString_1 = this.asString(it.getRight());
      return (_plus_2 + _asString_1);
    }
  }
  
  protected String _asString(final MultiplyOrDivide it) {
    Primary _right = it.getRight();
    boolean _tripleEquals = (_right == null);
    if (_tripleEquals) {
      return this.asString(it.getLeft());
    } else {
      String _asString = this.asString(it.getLeft());
      String _plus = (_asString + " ");
      String _operator = it.getOperator();
      String _plus_1 = (_plus + _operator);
      String _plus_2 = (_plus_1 + " ");
      String _asString_1 = this.asString(it.getRight());
      return (_plus_2 + _asString_1);
    }
  }
  
  protected String _asString(final Num it) {
    return Integer.valueOf(it.getValue()).toString();
  }
  
  protected String _asString(final VariableRef it) {
    return it.getValue().getName();
  }
  
  protected String _asString(final Bracket it) {
    String _asString = this.asString(it.getValue());
    String _plus = ("(" + _asString);
    return (_plus + ")");
  }
  
  protected String _asString(final Variable it) {
    String _name = it.getName();
    String _plus = (_name + " = ");
    String _asString = this.asString(it.getValue());
    return (_plus + _asString);
  }
  
  public int evaluate(final EObject it) {
    if (it instanceof Bracket) {
      return _evaluate((Bracket)it);
    } else if (it instanceof Num) {
      return _evaluate((Num)it);
    } else if (it instanceof VariableRef) {
      return _evaluate((VariableRef)it);
    } else if (it instanceof Expression) {
      return _evaluate((Expression)it);
    } else if (it instanceof MultiplyOrDivide) {
      return _evaluate((MultiplyOrDivide)it);
    } else if (it instanceof PlusOrMinus) {
      return _evaluate((PlusOrMinus)it);
    } else if (it instanceof Solution) {
      return _evaluate((Solution)it);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(it).toString());
    }
  }
  
  public String asString(final EObject it) {
    if (it instanceof Bracket) {
      return _asString((Bracket)it);
    } else if (it instanceof Num) {
      return _asString((Num)it);
    } else if (it instanceof VariableRef) {
      return _asString((VariableRef)it);
    } else if (it instanceof Expression) {
      return _asString((Expression)it);
    } else if (it instanceof MultiplyOrDivide) {
      return _asString((MultiplyOrDivide)it);
    } else if (it instanceof PlusOrMinus) {
      return _asString((PlusOrMinus)it);
    } else if (it instanceof Solution) {
      return _asString((Solution)it);
    } else if (it instanceof Variable) {
      return _asString((Variable)it);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(it).toString());
    }
  }
}
